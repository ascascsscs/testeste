<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SonicCut Pro - Editor de Áudio</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lamejs/1.2.1/lame.min.js"></script>

    <style>
        :root {
            --bg-dark: #09090b;
            --bg-panel: #18181b;
            --primary: #00f0ff; /* Ciano */
            --selection: #ff0055; /* Magenta */
            --selection-dim: rgba(255, 0, 85, 0.1);
            --text-main: #ffffff;
            --text-muted: #a1a1aa;
            --border: #27272a;
            --success: #00ff9d;
            --danger: #ff0055;
            --radius: 12px;
            --shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        header {
            background: rgba(9, 9, 11, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-size: 1.25rem;
            font-weight: 700;
            background: linear-gradient(90deg, var(--primary), var(--selection));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo svg { width: 24px; height: 24px; fill: var(--primary); }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem 1rem;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
        }

        /* Upload Zone */
        .upload-zone {
            width: 100%;
            max-width: 600px;
            height: 250px;
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--primary);
            background: rgba(0, 240, 255, 0.05);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.1);
        }

        .upload-icon { width: 64px; height: 64px; fill: var(--text-muted); margin-bottom: 1rem; transition: fill 0.3s; }
        .upload-zone:hover .upload-icon { fill: var(--primary); }
        
        .upload-text h3 { font-size: 1.1rem; margin-bottom: 0.5rem; }
        .upload-text p { font-size: 0.9rem; color: var(--text-muted); }
        input[type="file"] { display: none; }

        /* Editor Section */
        .editor-container { display: none; width: 100%; flex-direction: column; gap: 1.5rem; animation: fadeIn 0.5s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            position: relative;
        }

        /* Waveform Area */
        .waveform-wrapper {
            position: relative;
            width: 100%;
            height: 200px;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            user-select: none;
            touch-action: none; 
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* Máscaras Escuras */
        .dim-overlay {
            position: absolute;
            top: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            pointer-events: none;
            z-index: 5;
            transition: width 0.05s linear, left 0.05s linear;
        }
        
        #dim-left { left: 0; }
        #dim-right { right: 0; }

        /* Seleção (Magenta) */
        .trim-region {
            position: absolute;
            top: 0; bottom: 0;
            z-index: 10;
            pointer-events: none;
            border-top: 2px solid transparent;
            border-bottom: 2px solid transparent;
        }

        .trim-region::before {
            content: ''; position: absolute; top: 0; bottom: 0; left: 0; right: 0;
            border-left: 2px solid var(--selection);
            border-right: 2px solid var(--selection);
            box-shadow: inset 0 0 15px var(--selection-dim);
        }

        /* Handles */
        .trim-handle {
            position: absolute;
            top: 0; bottom: 0;
            width: 40px;
            cursor: ew-resize;
            pointer-events: all;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translateX(-50%);
        }

        .trim-handle::after {
            content: '';
            width: 6px;
            height: 30px;
            background: var(--selection);
            border-radius: 4px;
            box-shadow: 0 0 10px var(--selection);
        }

        .trim-handle.left { left: 0; }
        .trim-handle.right { right: 0; transform: translateX(50%); }

        /* Time Display */
        .time-display {
            display: flex;
            justify-content: space-between;
            margin-top: 1.5rem;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--selection);
            background: rgba(255, 0, 85, 0.05);
            padding: 10px;
            border-radius: 6px;
        }

        /* Controles */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            align-items: center;
        }

        button {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text-main);
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        button:hover { border-color: var(--primary); color: var(--primary); background: rgba(0, 240, 255, 0.05); }
        button:active { transform: scale(0.98); }

        button.playing-state {
            background: rgba(0, 255, 157, 0.1);
            border-color: var(--success);
            color: var(--success);
            box-shadow: 0 0 10px rgba(0, 255, 157, 0.1);
        }

        button.primary-btn {
            background: var(--selection);
            color: #fff;
            border: none;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.3);
        }

        button.primary-btn:hover {
            background: #ff3377;
            color: #fff;
            box-shadow: 0 0 25px rgba(255, 0, 85, 0.5);
        }

        /* Format Selector */
        .format-selector {
            display: flex;
            gap: 0.5rem;
            background: var(--bg-dark);
            padding: 4px;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .format-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-muted);
            transition: all 0.2s;
        }

        .format-option.active {
            background: var(--bg-panel);
            color: var(--text-main);
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            border-color: var(--primary);
            border-bottom: 2px solid var(--primary);
        }

        /* Toast */
        .toast-container {
            position: fixed;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: rgba(24, 24, 27, 0.95);
            backdrop-filter: blur(5px);
            border: 1px solid var(--border);
            padding: 12px 24px;
            border-radius: 50px;
            color: var(--text-main);
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slideUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .toast.error { border-color: var(--danger); color: #ffccc5; }
        .toast.success { border-color: var(--success); color: #ccffeb; }

        @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* Loader */
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(9, 9, 11, 0.9);
            z-index: 200;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .spinner {
            width: 50px; height: 50px;
            border: 3px solid rgba(255, 0, 85, 0.3);
            border-radius: 50%;
            border-top-color: var(--selection);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 600px) {
            .controls-grid { grid-template-columns: 1fr 1fr; }
            .full-width-mobile { grid-column: span 2; }
            .waveform-wrapper { height: 160px; }
        }
    </style>
</head>
<body>

<header>
    <div class="logo">
        <svg viewBox="0 0 24 24"><path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/></svg>
        SonicCut Pro
    </div>
    <button id="btn-reset" style="display:none; padding: 0.5rem; font-size: 0.8rem; border-color: var(--border);">
        Novo Arquivo
    </button>
</header>

<main>
    <!-- Tela de Upload -->
    <div id="upload-section" class="upload-zone">
        <svg class="upload-icon" viewBox="0 0 24 24"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg>
        <div class="upload-text">
            <h3>Toque ou Arraste seu Áudio</h3>
            <p>Suporta MP3, WAV, OGG, AAC</p>
        </div>
        <input type="file" id="file-input" accept="audio/*">
    </div>

    <!-- Editor Interface -->
    <div id="editor-section" class="editor-container">
        
        <!-- Painel de Visualização -->
        <div class="panel">
            <div class="waveform-wrapper" id="waveform-container">
                <canvas id="waveform-canvas"></canvas>
                
                <div id="dim-left" class="dim-overlay"></div>
                <div id="dim-right" class="dim-overlay"></div>
                
                <div id="trim-region" class="trim-region">
                    <div class="trim-handle left" id="handle-left" data-dir="left"></div>
                    <div class="trim-handle right" id="handle-right" data-dir="right"></div>
                </div>
            </div>

            <div class="time-display">
                <span id="time-start">00:00.000</span>
                <span style="color: var(--text-muted); font-weight: 400;">até</span>
                <span id="time-end">00:00.000</span>
            </div>
            <p style="text-align: center; font-size: 0.8rem; color: var(--text-muted); margin-top: 0.5rem;">
                Arraste as bordas rosas para selecionar o trecho
            </p>
        </div>

        <!-- Controles -->
        <div class="panel">
            <div class="controls-grid">
                <button id="btn-play">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                    Ouvir Trecho
                </button>
                
                <button id="btn-stop">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 6h12v12H6z"/></svg>
                    Parar
                </button>

                <div class="format-selector full-width-mobile">
                    <div class="format-option active" data-format="wav">WAV (Lossless)</div>
                    <div class="format-option" data-format="mp3">MP3 (Alta Qual.)</div>
                </div>

                <button id="btn-export" class="primary-btn full-width-mobile">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/></svg>
                    Salvar Corte
                </button>
            </div>
        </div>

    </div>
</main>

<div class="toast-container" id="toast-container"></div>
<div class="loading-overlay" id="loading-overlay">
    <div class="spinner"></div>
    <p id="loading-text" style="color: var(--text-main)">Processando...</p>
</div>

<script>
    /* ==========================================
       STATE & VARIABLES
       ========================================== */
    let audioContext = null;
    let audioBuffer = null;
    let sourceNode = null;
    
    let leftPercent = 0;
    let rightPercent = 100;
    let totalDuration = 0;
    let activeHandleDir = null; 
    
    let isPlaying = false;
    let selectedFormat = 'wav';

    // DOM Elements
    const uploadSection = document.getElementById('upload-section');
    const editorSection = document.getElementById('editor-section');
    const fileInput = document.getElementById('file-input');
    const canvas = document.getElementById('waveform-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('waveform-container');
    
    const trimRegion = document.getElementById('trim-region');
    const dimLeft = document.getElementById('dim-left');
    const dimRight = document.getElementById('dim-right');
    const handleLeft = document.getElementById('handle-left');
    const handleRight = document.getElementById('handle-right');
    
    const timeStartDisplay = document.getElementById('time-start');
    const timeEndDisplay = document.getElementById('time-end');
    
    const btnPlay = document.getElementById('btn-play');
    const btnStop = document.getElementById('btn-stop');
    const btnExport = document.getElementById('btn-export');
    const btnReset = document.getElementById('btn-reset');
    const formatOptions = document.querySelectorAll('.format-option');

    /* ==========================================
       INITIALIZATION & EVENTS
       ========================================== */
    
    uploadSection.addEventListener('click', () => fileInput.click());
    uploadSection.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadSection.classList.add('dragover');
    });
    uploadSection.addEventListener('dragleave', () => uploadSection.classList.remove('dragover'));
    uploadSection.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadSection.classList.remove('dragover');
        if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', (e) => {
        if (e.target.files.length) handleFile(e.target.files[0]);
    });

    btnReset.addEventListener('click', () => {
        stopAudio();
        audioBuffer = null;
        editorSection.style.display = 'none';
        uploadSection.style.display = 'flex';
        btnReset.style.display = 'none';
        fileInput.value = '';
    });

    btnPlay.addEventListener('click', playSelection);
    btnStop.addEventListener('click', stopAudio);

    formatOptions.forEach(opt => {
        opt.addEventListener('click', () => {
            formatOptions.forEach(o => o.classList.remove('active'));
            opt.classList.add('active');
            selectedFormat = opt.dataset.format;
        });
    });

    btnExport.addEventListener('click', exportAudio);

    window.addEventListener('resize', () => {
        if (audioBuffer) drawWaveform();
    });

    /* ==========================================
       AUDIO LOADING
       ========================================== */
    
    async function handleFile(file) {
        if (!file.type.startsWith('audio/')) {
            showToast('Selecione um arquivo de áudio válido.', 'error');
            return;
        }

        showLoading(true, 'Carregando áudio...');

        try {
            const arrayBuffer = await file.arrayBuffer();
            if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            totalDuration = audioBuffer.duration;

            leftPercent = 0;
            rightPercent = 100;

            uploadSection.style.display = 'none';
            editorSection.style.display = 'flex';
            btnReset.style.display = 'block';
            
            updateTrimVisuals();
            drawWaveform();
            showToast('Áudio carregado!', 'success');
        } catch (error) {
            console.error(error);
            showToast('Erro ao processar áudio.', 'error');
        } finally {
            showLoading(false);
        }
    }

    /* ==========================================
       WAVEFORM LOGIC
       ========================================== */
    function drawWaveform() {
        if (!audioBuffer) return;
        const width = container.clientWidth;
        const height = container.clientHeight;
        canvas.width = width;
        canvas.height = height;
        const data = audioBuffer.getChannelData(0);
        const step = Math.ceil(data.length / width);
        const amp = height / 2;
        
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim();
        
        for (let i = 0; i < width; i++) {
            let min = 1.0; let max = -1.0;
            for (let j = 0; j < step; j++) {
                const datum = data[(i * step) + j];
                if (datum < min) min = datum;
                if (datum > max) max = datum;
            }
            const yHigh = (1 + min) * amp;
            const yLow = (1 + max) * amp;
            ctx.fillRect(i, yHigh, 1, Math.max(1, yLow - yHigh));
        }
    }

    /* ==========================================
       SELECTION LOGIC
       ========================================== */
    
    const handles = [handleLeft, handleRight];
    handles.forEach(handle => {
        const startDrag = (e) => {
            e.preventDefault(); 
            e.stopPropagation(); 
            activeHandleDir = handle.dataset.dir;
            
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', endDrag);
        };
        
        handle.addEventListener('mousedown', startDrag);
        handle.addEventListener('touchstart', startDrag, { passive: false });
    });

    function onMove(e) {
        if (!activeHandleDir) return;
        e.preventDefault();

        const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        const rect = container.getBoundingClientRect();
        
        let newPercent = ((clientX - rect.left) / rect.width) * 100;
        
        if (newPercent < 0) newPercent = 0;
        if (newPercent > 100) newPercent = 100;

        if (activeHandleDir === 'left') {
            if (newPercent > rightPercent - 2) newPercent = rightPercent - 2;
            leftPercent = newPercent;
        } else {
            if (newPercent < leftPercent + 2) newPercent = leftPercent + 2;
            rightPercent = newPercent;
        }

        updateTrimVisuals();
    }

    function endDrag() {
        activeHandleDir = null;
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('touchend', endDrag);
    }

    function updateTrimVisuals() {
        dimLeft.style.width = `${leftPercent}%`;
        dimRight.style.width = `${100 - rightPercent}%`;
        
        const widthPercent = rightPercent - leftPercent;
        trimRegion.style.left = `${leftPercent}%`;
        trimRegion.style.width = `${widthPercent}%`;

        const startTime = (leftPercent / 100) * totalDuration;
        const endTime = (rightPercent / 100) * totalDuration;
        
        timeStartDisplay.textContent = formatTime(startTime);
        timeEndDisplay.textContent = formatTime(endTime);
    }

    function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        const ms = Math.floor((seconds % 1) * 1000);
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    }

    /* ==========================================
       PLAYBACK & EXPORT (CORREÇÃO DEFINITIVA)
       ========================================== */

    function playSelection() {
        // PARADA AGRESSIVA: Para e Desconecta tudo imediatamente
        stopAudio(); 

        if (!audioBuffer) return;

        // Cria nova fonte
        sourceNode = audioContext.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.connect(audioContext.destination);

        const startTime = (leftPercent / 100) * totalDuration;
        const duration = ((rightPercent - leftPercent) / 100) * totalDuration;
        
        if (duration <= 0) return;

        sourceNode.start(0, startTime, duration);
        isPlaying = true;

        // Atualiza UI
        btnPlay.classList.add('playing-state');
        btnPlay.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> Tocando...';
        
        sourceNode.onended = () => {
            isPlaying = false;
            sourceNode = null;
            resetPlayButtonUI();
        };
    }

    function stopAudio() {
        if (sourceNode) {
            try {
                sourceNode.stop();       // Para o tempo
                sourceNode.disconnect(); // Desconecta o cabo de áudio (evita eco)
            } catch (e) {
                // Ignora erros se já estiver parado
            }
            sourceNode = null; // Apaga a memória da fonte antiga
        }
        isPlaying = false;
        resetPlayButtonUI();
    }

    function resetPlayButtonUI() {
        btnPlay.classList.remove('playing-state');
        btnPlay.innerHTML = '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg> Ouvir Trecho';
    }

    async function exportAudio() {
        if (!audioBuffer) return;
        stopAudio();
        showLoading(true, 'Renderizando e codificando áudio...');

        const startTime = (leftPercent / 100) * totalDuration;
        const endTime = (rightPercent / 100) * totalDuration;
        const duration = endTime - startTime;
        
        const sampleRate = audioBuffer.sampleRate || 44100;
        const frameCount = Math.floor(duration * sampleRate);
        const startFrame = Math.floor(startTime * sampleRate);
        
        const offlineCtx = new OfflineAudioContext(
            audioBuffer.numberOfChannels,
            frameCount,
            sampleRate
        );

        const newBuffer = offlineCtx.createBuffer(
            audioBuffer.numberOfChannels,
            frameCount,
            sampleRate
        );

        for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
            const oldData = audioBuffer.getChannelData(i);
            const newData = newBuffer.getChannelData(i);
            for (let j = 0; j < frameCount; j++) {
                newData[j] = oldData[startFrame + j];
            }
        }

        try {
            if (selectedFormat === 'wav') {
                const wavBlob = bufferToWave(newBuffer, frameCount);
                downloadBlob(wavBlob, 'audio-cortado.wav');
            } else {
                if (typeof lamejs === 'undefined') throw new Error("LameJS não carregado");
                const mp3Blob = await encodeMP3(newBuffer);
                downloadBlob(mp3Blob, 'audio-cortado.mp3');
            }
            showToast('Download iniciado!', 'success');
        } catch (err) {
            console.error(err);
            showToast('Erro ao salvar: ' + err.message, 'error');
        } finally {
            showLoading(false);
        }
    }

    // --- WAV Encoder ---
    function bufferToWave(abuffer, len) {
        const numOfChan = abuffer.numberOfChannels;
        const length = len * numOfChan * 2 + 44;
        const buffer = new ArrayBuffer(length);
        const view = new DataView(buffer);
        let pos = 0;

        const writeString = (view, string, offset) => {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        };

        writeString(view, 'RIFF', pos); pos += 4;
        view.setUint32(pos, length - 8, true); pos += 4;
        writeString(view, 'WAVE', pos); pos += 4;
        writeString(view, 'fmt ', pos); pos += 4;
        view.setUint32(pos, 16, true); pos += 4;
        view.setUint16(pos, 1, true); pos += 2; // PCM
        view.setUint16(pos, numOfChan, true); pos += 2;
        view.setUint32(pos, abuffer.sampleRate, true); pos += 4;
        view.setUint32(pos, abuffer.sampleRate * 2 * numOfChan, true); pos += 4;
        view.setUint16(pos, numOfChan * 2, true); pos += 2;
        view.setUint16(pos, 16, true); pos += 2;
        writeString(view, 'data', pos); pos += 4;
        view.setUint32(pos, length - pos - 4, true); pos += 4;

        for (let i = 0; i < abuffer.numberOfChannels; i++) {
            const channelData = abuffer.getChannelData(i);
            for (let j = 0; j < len; j++) {
                let sample = Math.max(-1, Math.min(1, channelData[j]));
                sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(pos, sample, true);
                pos += 2;
            }
        }
        return new Blob([buffer], { type: "audio/wav" });
    }

    // --- MP3 Encoder ---
    function encodeMP3(buffer) {
        return new Promise((resolve, reject) => {
            const channels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const mp3encoder = new lamejs.Mp3Encoder(channels, sampleRate, 128);
            const mp3Data = [];
            
            const left = new Int16Array(buffer.length);
            const right = channels > 1 ? new Int16Array(buffer.length) : null;

            for (let i = 0; i < buffer.length; i++) {
                left[i] = floatTo16BitPCM(buffer.getChannelData(0)[i]);
                if (channels > 1) right[i] = floatTo16BitPCM(buffer.getChannelData(1)[i]);
            }

            const blockSize = 1152;
            for (let i = 0; i < buffer.length; i += blockSize) {
                const lChunk = left.subarray(i, i + blockSize);
                const rChunk = right ? right.subarray(i, i + blockSize) : null;
                const mp3buf = mp3encoder.encodeBuffer(lChunk, rChunk);
                if (mp3buf.length > 0) mp3Data.push(mp3buf);
            }
            const mp3buf = mp3encoder.flush();
            if (mp3buf.length > 0) mp3Data.push(mp3buf);
            resolve(new Blob(mp3Data, { type: 'audio/mp3' }));
        });
    }

    function floatTo16BitPCM(input) {
        let s = Math.max(-1, Math.min(1, input));
        return s < 0 ? s * 0x8000 : s * 0x7FFF;
    }

    function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    }

    function showToast(msg, type) {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerText = msg;
        container.appendChild(toast);
        setTimeout(() => { toast.remove(); }, 3000);
    }

    function showLoading(show, text) {
        const el = document.getElementById('loading-overlay');
        const txt = document.getElementById('loading-text');
        txt.innerText = text;
        el.style.display = show ? 'flex' : 'none';
    }

</script>
</body>
</html>
